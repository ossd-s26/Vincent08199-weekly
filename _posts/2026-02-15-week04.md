---

layout: post
title: "Week 3 – Git Workflow and Open Source Readiness"
--------------------------------------------------------

## Comment on the Git Exercises

This week’s Git exercises helped me move from using Git mechanically to understanding its internal model. Before this course, I often treated Git as a set of commands to memorize. Now I see it more as a structured system that manages the lifecycle of changes.

One concept that became much clearer is the three states of a file: modified, staged, and committed. The slides explain that a modified file has been changed but not recorded, a staged file is marked for the next snapshot, and a committed file is safely stored in the local Git database.  This state model explains many behaviors that previously felt confusing.

The “loading dock” mental model was especially helpful for me. Thinking of the working directory as a workbench, the staging area as a filtering checkpoint, and the repository as the permanent record makes the workflow logically consistent. It also highlights why Git includes the staging step — it gives developers precise control over what enters each commit.

After practicing commands like `git status`, `git add`, and `git log`, I started to see Git less as a tool and more as an infrastructure layer for collaborative software development.

## Thoughts on Project Evaluation

Looking at different open source projects this week, I noticed that the technical quality of the code is only one part of what makes a project approachable. Repository organization, documentation clarity, issue labeling, and contributor guidelines all strongly affect whether newcomers can participate.

Projects with clear READMEs, active maintainers, and well-scoped issues feel significantly more welcoming. In contrast, even technically strong projects can feel difficult to enter if the social and organizational structure is weak. This reinforced my view that open source is both a technical system and a coordination system.

What excites me most about working on open source is the opportunity to contribute to software that exists beyond the classroom. Unlike isolated assignments, open source contributions become part of a living codebase. This creates a stronger sense of responsibility and long-term impact.

## Biggest Challenges

The biggest challenge I anticipate is navigating large codebases efficiently. Mature open source projects often contain many layers of abstraction, and understanding where to begin is not trivial.

Another challenge is developing good open source communication habits. Writing meaningful commit messages, participating in issue discussions, and aligning with project conventions require a different mindset than solo programming.

## How I Plan to Overcome Them

To handle the codebase complexity, I plan to adopt a “small surface area” strategy. I will begin by reading documentation, mapping the repository structure, and focusing on small, well-defined issues. Tools like `git log --oneline` and `git diff` should help me understand how specific parts of the code evolved.

For the collaboration challenge, I plan to learn by observation and gradual participation. I will study how experienced contributors structure pull requests and communicate with maintainers. Over time, I hope to develop habits that make my contributions easier to review and integrate.

Overall, this week shifted my perspective: Git is not just about saving versions of files. It is a coordination mechanism that enables distributed software development at scale. Understanding this system-level view will be important as I begin contributing to open source projects more seriously.
